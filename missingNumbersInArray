
import java.util.Arrays;

public class Main {
    public static int firstMissingPositiveNumber(int[] num) {
        int missingNumber = 1;

        for (int number : num) {
            if (number == missingNumber) {
                missingNumber++;
            } else if (number > missingNumber) {
                return missingNumber;
            }
        }

        return missingNumber;
    }

    public static void main(String[] args) {
        int[] num = {3, 4, -1, 1};
        int result = firstMissingPositiveNumber(num);
        System.out.println("First missing positive number: " + result);
    }
}

Similar problems
1) Find All Numbers Disappeared in an Array: Given an array of integers where 1 ≤ a[i] ≤ n (n is the size of the array), 
   some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array.
   For example, given nums = [4, 3, 2, 7, 8, 2, 3, 1], the output should be [5, 6]

    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.List;
    
    public class Main {
        public static List<Integer> findMissingNumbers(int[] a) {
            List<Integer> missingNumbers = new ArrayList<>();
            int length = a.length;
            int[] newArray = new int[length];
            Arrays.fill(newArray, -1);
    
            for (int number : a) {
                newArray[number - 1] = number;
            }
    
            for (int i = 1; i <= length; i++) {
                if (newArray[i - 1] == -1) {
                    missingNumbers.add(i);
                }
            }
    
            return missingNumbers;
        }
    
        public static void main(String[] args) {
            int[] a = {4, 3, 2, 7, 8, 2, 3, 1};
            List<Integer> missingNumbers = findMissingNumbers(a);
            System.out.println("Missing numbers: " + missingNumbers);
        }
    }

Improved complexity using Set

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Main {
    public static List<Integer> findMissingNumbers(int[] a) {
        List<Integer> missingNumbers = new ArrayList<>();
        Set<Integer> numSet = new HashSet<>();
        int maxNum = Integer.MIN_VALUE;

        // Populate the set and find the maximum number
        for (int num : a) {
            numSet.add(num);
            maxNum = Math.max(maxNum, num);
        }

        // Iterate from 1 to the maximum number and add missing numbers to the list
        for (int i = 1; i <= maxNum; i++) {
            if (!numSet.contains(i)) {
                missingNumbers.add(i);
            }
        }

        return missingNumbers;
    }

    public static void main(String[] args) {
        int[] a = {4, 3, 2, 7, 8, 2, 3, 1};
        List<Integer> missingNumbers = findMissingNumbers(a);
        System.out.println("Missing numbers: " + missingNumbers);
    }
}


2) Find the Duplicate Number: Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive),
   prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

    public class Main {
        public static int findDuplicateNumber(int[] a) {
            for (int i = 0; i < a.length; i++) {
                int index = Math.abs(a[i]);
                if (a[index] < 0) {
                    System.out.println("Duplicate found: " + index);
                    return index;
                } else {
                    a[index] = -a[index];
                }
            }
            return -1; // No duplicate found
        }
    
        public static void main(String[] args) {
            int[] nums = {1, 3, 4, 2, 2};
            findDuplicateNumber(nums);
        }
    }

